.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Signal 3"
.TH Signal 3 "2015-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coro::Signal \- thread signals (binary semaphores)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Coro;
\&
\& my $sig = new Coro::Signal;
\&
\& $sig\->wait; # wait for signal
\&
\& # ... some other "thread"
\&
\& $sig\->send;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements signals/binary semaphores/condition variables
(basically all the same thing). You can wait for a signal to occur or send
it, in which case it will wake up one waiter, or it can be broadcast,
waking up all waiters.
.PP
It is recommended not to mix \f(CW\*(C`send\*(C'\fR and \f(CW\*(C`broadcast\*(C'\fR calls on the same
\&\f(CW\*(C`Coro::Signal\*(C'\fR without some deep thinking: while it should work as
documented, it can easily confuse you :\->
.PP
You don't have to load \f(CW\*(C`Coro::Signal\*(C'\fR manually, it will be loaded
automatically when you \f(CW\*(C`use Coro\*(C'\fR and call the \f(CW\*(C`new\*(C'\fR constructor.
.ie n .IP "$sig = new Coro::Signal;" 4
.el .IP "\f(CW$sig\fR = new Coro::Signal;" 4
.IX Item "$sig = new Coro::Signal;"
Create a new signal.
.ie n .IP "$sig\->wait" 4
.el .IP "\f(CW$sig\fR\->wait" 4
.IX Item "$sig->wait"
Wait for the signal to occur (via either \f(CW\*(C`send\*(C'\fR or \f(CW\*(C`broadcast\*(C'\fR). Returns
immediately if the signal has been sent before.
.ie n .IP "$sig\->wait ($callback)" 4
.el .IP "\f(CW$sig\fR\->wait ($callback)" 4
.IX Item "$sig->wait ($callback)"
If you pass a callback argument to \f(CW\*(C`wait\*(C'\fR, it will not wait, but
immediately return. The callback will be called under the same conditions
as \f(CW\*(C`wait\*(C'\fR without arguments would continue the thrad.
.Sp
The callback might wake up any number of threads, but is \fI\s-1NOT\s0\fR allowed to
block (switch to other threads).
.ie n .IP "$sig\->send" 4
.el .IP "\f(CW$sig\fR\->send" 4
.IX Item "$sig->send"
Send the signal, waking up \fIone\fR waiting process or remember the signal
if no process is waiting.
.ie n .IP "$sig\->broadcast" 4
.el .IP "\f(CW$sig\fR\->broadcast" 4
.IX Item "$sig->broadcast"
Send the signal, waking up \fIall\fR waiting process. If no process is
waiting the signal is lost.
.ie n .IP "$sig\->awaited" 4
.el .IP "\f(CW$sig\fR\->awaited" 4
.IX Item "$sig->awaited"
Return true when the signal is being awaited by some process.
.SH "AUTHOR/SUPPORT/CONTACT"
.IX Header "AUTHOR/SUPPORT/CONTACT"
.Vb 2
\&   Marc A. Lehmann <schmorp@schmorp.de>
\&   http://software.schmorp.de/pkg/Coro.html
.Ve
